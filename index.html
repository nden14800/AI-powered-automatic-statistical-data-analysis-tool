<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI搭載 統計データ自動分析ツール</title>

    <!-- Google Fonts: Roboto -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">

    <!-- KaTeX CSS (v0.16.22) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP" crossorigin="anonymous">

    <!-- Highcharts.js for graphs -->
    <script src="https://code.highcharts.com/highcharts.js"></script>
    
    <!-- KaTeX JS (v0.16.22) - deferred -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js" integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6" crossorigin="anonymous"></script>

    <!-- KaTeX Auto-render extension (v0.16.22) - deferred with onload as per template -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>

    <style>
        :root {
            --bg-color: #f4f7f9; --text-color: #2c3e50; --card-bg-color: #ffffff; --border-color: #e0e0e0; --primary-color: #3498db; --primary-text-color: #ffffff; --input-bg-color: #ecf0f1; --table-header-bg: #f2f2f2; --highlight-bg: rgba(52, 152, 219, 0.1); --spinner-color: #3498db;
        }
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #1a1a2e; --text-color: #e0e0e0; --card-bg-color: #16213e; --border-color: #444; --primary-color: #0f3460; --primary-text-color: #e94560; --input-bg-color: #2c3e50; --table-header-bg: #1e2a4a; --highlight-bg: rgba(233, 69, 96, 0.15); --spinner-color: #e94560;
            }
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Roboto', 'Noto Sans JP', sans-serif; background-color: var(--bg-color); color: var(--text-color); line-height: 1.6; transition: background-color 0.3s, color 0.3s; }
        main { max-width: 900px; margin: 2rem auto; padding: 1rem; }
        header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; }
        h1 { font-size: 1.8rem; color: var(--text-color); }
        h2 { text-align: center; margin-bottom: 1.5rem; color: var(--primary-text-color); background-color: var(--primary-color); padding: 0.5rem; border-radius: 8px; }
        h2.flex-header { display: flex; align-items: center; justify-content: center; gap: 0.5rem; }
        .card { background-color: var(--card-bg-color); padding: 1.5rem; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); margin-bottom: 2rem; border: 1px solid var(--border-color); }
        .input-group { display: flex; flex-direction: column; gap: 1rem; }
        label { font-weight: 500; }
        textarea, input[type="text"], input[type="number"], input[type="password"] { width: 100%; padding: 0.8rem; border-radius: 4px; border: 1px solid var(--border-color); background-color: var(--input-bg-color); color: var(--text-color); font-size: 1rem; font-family: 'Roboto', monospace; }
        textarea { min-height: 120px; resize: vertical; }
        button { padding: 0.8rem 1.5rem; background-color: var(--primary-color); color: var(--primary-text-color); border: none; border-radius: 4px; font-size: 1.1rem; font-weight: 700; cursor: pointer; transition: background-color 0.2s; }
        button:hover { opacity: 0.9; }
        .icon-button { background: none; border: 1px solid var(--border-color); padding: 0.5rem; border-radius: 50%; width: 40px; height: 40px; display: flex; justify-content: center; align-items: center; color: var(--text-color); }
        .icon-button svg { width: 20px; height: 20px; }
        #results { display: none; }
        .stats-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-top: 1rem; }
        .stat-item { padding: 1rem; border: 1px solid var(--border-color); border-radius: 6px; display: flex; flex-direction: column; }
        .stat-item h3 { margin-bottom: 0.5rem; }
        .stat-value { font-size: 1.8rem; font-weight: 700; color: var(--primary-text-color); background-color: var(--primary-color); padding: 0.2rem 0.5rem; border-radius: 4px; display: inline-block; margin-bottom: 1rem; word-break: break-all; }
        .formula { font-size: 1.1rem; padding: 0.5rem; background-color: var(--input-bg-color); border-radius: 4px; overflow-x: auto; flex-grow: 1; }
        .table-container { overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
        th, td { border: 1px solid var(--border-color); padding: 0.8rem; text-align: center; }
        thead { background-color: var(--table-header-bg); font-weight: 700; }
        #dataTable td { padding: 0.5rem; }
        .chart-container { width: 100%; height: 400px; }
        .explanation { padding: 0.5rem; margin-bottom: 0.5rem; border-left: 3px solid var(--primary-color); background-color: var(--highlight-bg); }
        .formula p { word-break: break-all; }
        .disclaimer { font-size: 0.8rem; text-align: center; opacity: 0.7; margin-top: 1rem; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
        .modal-overlay.visible { opacity: 1; visibility: visible; }
        .modal-content { background: var(--card-bg-color); padding: 2rem; border-radius: 8px; width: 90%; max-width: 500px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .modal-content h3 { margin-top: 0; }
        .modal-actions { display: flex; justify-content: flex-end; gap: 1rem; margin-top: 1.5rem; }
        .loader-container { display: none; flex-direction: column; justify-content: center; align-items: center; min-height: 100px; }
        .loader { width: 60px; height: 60px; animation: rotate 1s linear infinite; transform-origin: center center; }
        .loader .path { stroke: var(--spinner-color); stroke-linecap: round; stroke-dasharray: 89 150; stroke-dashoffset: 0; }
        @keyframes rotate { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <main>
        <header>
            <h1>AI搭載 統計データ自動分析ツール</h1>
            <button id="settingsBtn" class="icon-button" title="設定">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-gear" viewBox="0 0 16 16"><path d="M8 4.754a3.246 3.246 0 1 0 0 6.492 3.246 3.246 0 0 0 0-6.492M5.754 8a2.246 2.246 0 1 1 4.492 0 2.246 2.246 0 0 1-4.492 0"/><path d="M9.796 1.343c-.527-1.79-3.065-1.79-3.592 0l-.094.319a.873.873 0 0 1-1.255.52l-.292-.16c-1.64-.892-3.433.902-2.54 2.541l.159.292a.873.873 0 0 1-.52 1.255l-.319.094c-1.79.527-1.79 3.065 0 3.592l.319.094a.873.873 0 0 1 .52 1.255l-.16.292c-.892 1.64.901 3.434 2.541 2.54l.292-.159a.873.873 0 0 1 1.255.52l.094.319c.527 1.79 3.065 1.79 3.592 0l.094-.319a.873.873 0 0 1 1.255-.52l.292.16c1.64.893 3.434-.902 2.54-2.541l-.159-.292a.873.873 0 0 1 .52-1.255l.319-.094c-1.79-.527-1.79-3.065 0-3.592l-.319-.094a.873.873 0 0 1-.52-1.255l.16-.292c.893-1.64-.902-3.433-2.541-2.54l-.292.159a.873.873 0 0 1-1.255-.52zm-2.633.283c.246-.835 1.428-.835 1.674 0l.094.319a1.873 1.873 0 0 0 2.693 1.115l.291-.16c.764-.415 1.6.42 1.184 1.185l-.159.292a1.873 1.873 0 0 0 1.116 2.692l.318.094c.835.246.835 1.428 0 1.674l-.319.094a1.873 1.873 0 0 0-1.115 2.693l.16.291c.415.764-.42 1.6-1.185 1.184l-.291-.159a1.873 1.873 0 0 0-2.693 1.116l-.094.318c-.246.835-1.428.835-1.674 0l-.094-.319a1.873 1.873 0 0 0-2.692-1.115l-.292.16c-.764.415-1.6-.42-1.184-1.185l.159.291A1.873 1.873 0 0 0 1.945 8.93l-.319-.094c-.835-.246-.835-1.428 0-1.674l.319-.094A1.873 1.873 0 0 0 3.06 4.377l-.16-.292c-.415-.764.42-1.6 1.185-1.184l.292.159a1.873 1.873 0 0 0 2.692-1.115z"/></svg>
            </button>
        </header>

        <div class="card">
            <h2>データ入力</h2>
            <div class="input-group">
                <label for="dataInput">データをカンマ(,)、スペース、または改行で区切って入力してください。</label>
                <textarea id="dataInput" placeholder="例: 1, 2, 2, 3, 5, 8, 10, 11, 15, 16, 18, 22"></textarea>
                <label for="binWidth">ヒストグラムの階級の幅（整数）</label>
                <input type="number" id="binWidth" value="5" min="1" step="1">
                <button id="calculateBtn">分析する</button>
            </div>
        </div>
        <div id="results">
            <div class="card">
                <h2 class="flex-header">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-stars" viewBox="0 0 16 16"><path d="M7.657 6.247c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937-.645a2.89 2.89 0 0 0 1.828-1.828zM3.794 1.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387A1.73 1.73 0 0 0 4.593 5.69l-.387 1.162a.217.217 0 0 1-.412 0L3.407 5.69A1.73 1.73 0 0 0 2.31 4.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387A1.73 1.73 0 0 0 3.407 2.31zM10.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.16 1.16 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.16 1.16 0 0 0-.732-.732L9.1 2.137a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732z"/></svg>
                    AIによるデータ要約
                </h2>
                <div id="aiSpinner" class="loader-container">
                    <svg class="loader" viewBox="0 0 50 50">
                        <circle class="path" cx="25" cy="25" r="20" fill="none" stroke-width="4"></circle>
                    </svg>
                </div>
                <div id="aiSummaryContent"></div>
                <p class="disclaimer">AIによるデータ要約には、間違いが含まれている場合があります。</p>
            </div>
            <div class="card">
                <h2>基本統計量</h2>
                <div class="stats-container">
                    <div class="stat-item"><h3>合計値 (Sum)</h3><div id="sumValue" class="stat-value"></div><div class="formula" id="sumFormula"></div></div>
                    <div class="stat-item"><h3>平均値 (Mean)</h3><div id="meanValue" class="stat-value"></div><div class="formula" id="meanFormula"></div></div>
                    <div class="stat-item"><h3>中央値 (Median)</h3><div id="medianValue" class="stat-value"></div><div class="formula" id="medianFormula"></div></div>
                    <div class="stat-item"><h3>最頻値 (Mode)</h3><div id="modeValue" class="stat-value"></div><div class="formula" id="modeFormula"></div></div>
                </div>
            </div>
            <div class="card"><h2>データ一覧（昇順）</h2><div class="table-container"><table id="dataTable"><tbody></tbody></table></div></div>
            <div class="card"><h2>ドットプロット</h2><div id="dotPlotContainer" class="chart-container"></div></div>
            <div class="card"><h2>ヒストグラム（柱状グラフ）</h2><div id="histogramContainer" class="chart-container"></div></div>
            <div class="card"><h2>度数分布表</h2><div class="table-container"><table id="frequencyTable"><thead><tr><th>階級</th><th>度数（個数）</th></tr></thead><tbody></tbody></table></div></div>
        </div>
    </main>

    <div id="settingsModal" class="modal-overlay">
        <div class="modal-content">
            <h3>設定</h3>
            <div class="input-group">
                <label for="apiKeyInput">Google AI APIキー</label>
                <input type="password" id="apiKeyInput" placeholder="APIキーを入力してください">
                <p style="font-size: 0.8rem; opacity: 0.8;">APIキーは <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener">Google AI Studio</a> で取得できます。入力されたキーはブラウザ内にのみ保存されます。</p>
            </div>
            <div class="modal-actions">
                <button id="closeModalBtn" style="background-color: grey;">閉じる</button>
                <button id="saveApiKeyBtn">保存</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const calculateBtn = document.getElementById('calculateBtn');
            const settingsBtn = document.getElementById('settingsBtn');
            const settingsModal = document.getElementById('settingsModal');
            const closeModalBtn = document.getElementById('closeModalBtn');
            const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
            const apiKeyInput = document.getElementById('apiKeyInput');

            calculateBtn.addEventListener('click', analyzeData);
            
            settingsBtn.addEventListener('click', () => {
                apiKeyInput.value = localStorage.getItem('geminiApiKey') || '';
                settingsModal.classList.add('visible');
            });

            closeModalBtn.addEventListener('click', () => settingsModal.classList.remove('visible'));
            
            saveApiKeyBtn.addEventListener('click', () => {
                localStorage.setItem('geminiApiKey', apiKeyInput.value);
                settingsModal.classList.remove('visible');
            });

            settingsModal.addEventListener('click', (e) => {
                if (e.target === settingsModal) {
                    settingsModal.classList.remove('visible');
                }
            });
        });
        
        async function analyzeData() {
            const rawData = document.getElementById('dataInput').value;
            const numbers = rawData.split(/[\s,]+/).filter(n => n !== "").map(Number).filter(n => !isNaN(n));
            if (numbers.length === 0) { alert('有効なデータが入力されていません。'); return; }
            numbers.sort((a, b) => a - b);
            
            const sum = calculateSum(numbers);
            const mean = calculateMean(numbers);
            const median = calculateMedian(numbers);
            const modeResult = calculateMode(numbers);
            const binWidth = parseInt(document.getElementById('binWidth').value);
            if (isNaN(binWidth) || binWidth <= 0) { alert('階級の幅は正の整数で入力してください。'); return; }

            const frequencyData = createFrequencyData(numbers, binWidth);
            const dotPlotData = createDotPlotData(numbers);
            
            displayResults(sum, mean, median, modeResult.text, numbers);
            renderDataTable(numbers);
            renderFrequencyTable(frequencyData);
            
            setHighchartsTheme();
            renderDotPlot(dotPlotData);
            renderHistogram(frequencyData);

            await getAISummary(numbers, { sum, mean, median, mode: modeResult.text });

            // 【重要】動的に生成した数式をKaTeXで再レンダリングする
            // displayResults関数で数式を含むHTMLをDOMに挿入した後に、この関数を呼び出す必要があります。
            if (window.renderMathInElement) {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ]
                });
            }
        }

        async function getAISummary(data, stats) {
            const aiSpinner = document.getElementById('aiSpinner');
            const aiSummaryContent = document.getElementById('aiSummaryContent');
            const apiKey = localStorage.getItem('geminiApiKey');

            aiSummaryContent.innerHTML = '';
            
            if (!apiKey) {
                aiSummaryContent.innerHTML = '<p>AI要約を利用するには、設定からAPIキーを登録してください。</p>';
                return;
            }

            aiSpinner.style.display = 'flex';

            const prompt = `あなたは優秀なデータ分析アシスタントです。以下のデータセットとその基本統計量に基づいて、データの特性について簡潔で分かりやすい要約を作成してください。

            重点的に分析するポイント：
            - 中心の傾向：平均値と中央値は近いか？どちらがデータ全体をよりよく表しているか？
            - ばらつき：データの範囲（最小値と最大値）は広いか？特定の値に集中しているか？
            - 分布の形状：最頻値は存在するか？データは山のような形をしているか、それとも平坦か？
            
            ---
            ### データセット (${data.length}個)
            ${data.join(', ')}

            ### 基本統計量
            - 合計値: ${stats.sum.toLocaleString()}
            - 平均値: ${stats.mean.toFixed(3)}
            - 中央値: ${stats.median.toFixed(3)}
            - 最頻値: ${stats.mode}
            ---

            以上の情報を基に、データ全体の傾向を要約してください。`;
            
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error.message || `HTTPエラー: ${response.status}`);
                }

                const responseData = await response.json();
                const summaryText = responseData.candidates[0].content.parts[0].text;
                aiSummaryContent.textContent = summaryText;

            } catch (error) {
                console.error('AI要約の生成に失敗しました:', error);
                aiSummaryContent.innerHTML = `<p style="color: red;">要約の生成中にエラーが発生しました。APIキーが正しいか、指定されたモデル名が有効か確認するか、ブラウザのコンソールで詳細を確認してください。</p>`;
            } finally {
                aiSpinner.style.display = 'none';
            }
        }
        
        function calculateSum(arr) { return arr.reduce((acc, val) => acc + val, 0); }
        function calculateMean(arr) { return arr.length > 0 ? arr.reduce((acc, val) => acc + val, 0) / arr.length : 0; }
        function calculateMedian(arr) { const mid = Math.floor(arr.length / 2); return arr.length % 2 !== 0 ? arr[mid] : (arr[mid - 1] + arr[mid]) / 2; }
        function calculateMode(arr) {
            const freq = arr.reduce((acc, val) => { acc[val] = (acc[val] || 0) + 1; return acc; }, {});
            let maxFreq = 0, modes = [];
            for (const num in freq) { if (freq[num] > maxFreq) { modes = [Number(num)]; maxFreq = freq[num]; } else if (freq[num] === maxFreq) { modes.push(Number(num)); } }
            if (modes.length === Object.keys(freq).length && modes.length > 1) return { text: "なし", values: [] };
            return { text: modes.join(', '), values: modes };
        }
        
        function createFrequencyData(numbers, binWidth) {
            if (numbers.length === 0) return [];
            const min = Math.floor(numbers[0] / binWidth) * binWidth;
            const max = numbers[numbers.length - 1];
            const bins = {};
            for (let i = min; i <= max; i += binWidth) { bins[`${i} 以上 ${i + binWidth} 未満`] = 0; }
            numbers.forEach(num => { const binStart = Math.floor(num / binWidth) * binWidth; const label = `${binStart} 以上 ${binStart + binWidth} 未満`; if (bins[label] !== undefined) bins[label]++; });
            return Object.entries(bins).map(([label, count]) => ({ label, count }));
        }
        function createDotPlotData(numbers) {
            const freq = {}; numbers.forEach(num => { freq[num] = (freq[num] || 0) + 1; });
            const plotData = [];
            for (const num in freq) { for (let i = 1; i <= freq[num]; i++) { plotData.push({ x: Number(num), y: i }); } }
            return plotData;
        }

        function displayResults(sum, mean, median, modeText, arr) {
            document.getElementById('results').style.display = 'block';
            document.getElementById('sumValue').textContent = sum.toLocaleString();
            document.getElementById('meanValue').textContent = mean.toFixed(3);
            document.getElementById('medianValue').textContent = median.toFixed(3);
            document.getElementById('modeValue').textContent = modeText;
            document.getElementById('sumFormula').innerHTML = `<div class="explanation">合計値は、すべてのデータを足し合わせて求めます。</div>$$ \\text{合計} = ${arr.join(' + ')} $$$$ \\text{合計} = ${sum.toLocaleString()} $$`;
            document.getElementById('meanFormula').innerHTML = `<div class="explanation">平均値(m)は、データの合計をデータの数で割って求めます。</div>$$ m = \\frac{\\text{データの合計}}{\\text{データの数}} $$$$ m = \\frac{${sum.toLocaleString()}}{${arr.length}} \\approx ${mean.toFixed(3)} $$`;
            let medianFormulaHTML = `<div class="explanation">中央値を求めるには、まずデータを小さい順に並べ替えます。</div>`;
            const n = arr.length;
            medianFormulaHTML += `<p>並べ替えたデータ (${n}個):<br>${formatArrayWithHighlight(arr)}</p>`;
            if (n % 2 !== 0) {
                const midIndex = Math.floor(n / 2);
                medianFormulaHTML += `<div class="explanation">データ数が奇数 (${n}個) の場合は、真ん中 (${midIndex + 1}番目) の値が中央値です。</div><p>${formatArrayWithHighlight(arr, [midIndex])}</p>$$ \\text{中央値} = ${arr[midIndex]} $$`;
            } else {
                const mid1 = n / 2 - 1, mid2 = n / 2;
                medianFormulaHTML += `<div class="explanation">データ数が偶数 (${n}個) の場合は、真ん中に最も近い2つの値 (${mid1 + 1}番目と${mid2 + 1}番目) の平均値が中央値です。</div><p>${formatArrayWithHighlight(arr, [mid1, mid2])}</p>$$ \\text{中央値} = \\frac{${arr[mid1]} + ${arr[mid2]}}{2} = \\frac{${arr[mid1] + arr[mid2]}}{2} = ${median} $$`;
            }
            document.getElementById('medianFormula').innerHTML = medianFormulaHTML;
            document.getElementById('modeFormula').innerHTML = `<div class="explanation">最頻値は、データの中で最も多く出現する値です。すべてのデータを比較し、最も頻繁に現れる数値を直接見つけます。</div>`;
        }
        
        function renderDataTable(arr) {
            const tbody = document.querySelector('#dataTable tbody');
            tbody.innerHTML = '';
            const cols = 10;
            let tr = document.createElement('tr');
            for (let i = 0; i < arr.length; i++) {
                if (i > 0 && i % cols === 0) { tbody.appendChild(tr); tr = document.createElement('tr'); }
                const td = document.createElement('td'); td.textContent = arr[i]; tr.appendChild(td);
            }
            tbody.appendChild(tr);
        }
        function renderFrequencyTable(data) { const tbody = document.querySelector('#frequencyTable tbody'); tbody.innerHTML = ''; data.filter(item => item.count > 0).forEach(item => { const row = document.createElement('tr'); row.innerHTML = `<td>${item.label}</td><td>${item.count}</td>`; tbody.appendChild(row); }); }
        function setHighchartsTheme() { const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches; const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim(); const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--card-bg-color').trim(); const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim(); Highcharts.setOptions({ chart: { backgroundColor: bgColor, style: { fontFamily: 'Roboto, sans-serif' } }, title: { style: { color: textColor } }, xAxis: { labels: { style: { color: textColor } }, title: { style: { color: textColor } }, gridLineColor: gridColor, lineColor: gridColor }, yAxis: { labels: { style: { color: textColor } }, title: { style: { color: textColor } }, gridLineColor: gridColor }, legend: { enabled: false }, tooltip: { backgroundColor: isDarkMode ? 'rgba(30, 42, 74, 0.85)' : 'rgba(255, 255, 255, 0.85)', style: { color: textColor } }, credits: { enabled: false } }); }
        function renderDotPlot(data) { const dotColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim(); Highcharts.chart('dotPlotContainer', { chart: { type: 'scatter' }, title: { text: null }, xAxis: { title: { text: '値' } }, yAxis: { title: { text: '度数（積み上げ）' }, min: 0, allowDecimals: false, tickInterval: 1 }, series: [{ name: 'データ点', data: data, color: dotColor, marker: { radius: 5 } }], tooltip: { formatter: function () { return `値: <b>${this.x}</b><br/>${this.y}番目の点`; } } }); }
        function renderHistogram(data) { const barColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim(); const filteredData = data.filter(d => d.count > 0); Highcharts.chart('histogramContainer', { chart: { type: 'column' }, title: { text: null }, xAxis: { categories: filteredData.map(d => d.label), title: { text: '階級' } }, yAxis: { min: 0, title: { text: '度数' }, allowDecimals: false }, plotOptions: { column: { pointPadding: 0, borderWidth: 1, groupPadding: 0, shadow: false, borderColor: getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim() } }, series: [{ name: '度数', data: filteredData.map(d => d.count), color: barColor }], tooltip: { headerFormat: '<span style="font-size:10px">{point.key}</span><table>', pointFormat: '<tr><td style="padding:0">度数: </td><td style="padding:0"><b>{point.y}</b></td></tr>', footerFormat: '</table>', useHTML: true } }); }
        
        function formatArrayWithHighlight(arr, highlightIndices = []) {
            const content = arr.map((val, i) => highlightIndices.includes(i) ? `<strong>${val}</strong>` : val).join(', ');
            return `[${content}]`;
        }
    </script>
</body>
</html>
