<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI搭載 統計データ自動分析ツール</title>

    <!-- Google Fonts: Roboto -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">

    <!-- KaTeX CSS (v0.16.22) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP" crossorigin="anonymous">

    <!-- Highcharts.js Core and Modules -->
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <script src="https://code.highcharts.com/highcharts-more.js"></script>
    <!-- Modules for new features: Exporting, Data Export, and Accessibility -->
    <script src="https://code.highcharts.com/modules/exporting.js"></script>
    <script src="https://code.highcharts.com/modules/export-data.js"></script>
    <script src="https://code.highcharts.com/modules/accessibility.js"></script>
    
    <!-- KaTeX JS (v0.16.22) - deferred -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js" integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6" crossorigin="anonymous"></script>

    <!-- KaTeX Auto-render extension (v0.16.22) - deferred -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>

    <style>
        :root {
            --bg-color: #f4f7f9; --text-color: #2c3e50; --card-bg-color: #ffffff; --border-color: #e0e0e0; --primary-color: #3498db; --primary-text-color: #ffffff; --input-bg-color: #ecf0f1; --table-header-bg: #f2f2f2; --highlight-bg: rgba(52, 152, 219, 0.1); --spinner-color: #3498db;
        }
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #1a1a2e; --text-color: #e0e0e0; --card-bg-color: #16213e; --border-color: #444; --primary-color: #0f3460; --primary-text-color: #e94560; --input-bg-color: #2c3e50; --table-header-bg: #1e2a4a; --highlight-bg: rgba(233, 69, 96, 0.15); --spinner-color: #e94560;
            }
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Roboto', sans-serif; background-color: var(--bg-color); color: var(--text-color); line-height: 1.6; transition: background-color 0.3s, color 0.3s; }
        main { max-width: 900px; margin: 2rem auto; padding: 1rem; }
        header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; }
        h1 { font-size: 1.8rem; color: var(--text-color); }
        h2 { text-align: center; margin-bottom: 1.5rem; color: var(--primary-text-color); background-color: var(--primary-color); padding: 0.5rem; border-radius: 8px; }
        h2.flex-header { display: flex; align-items: center; justify-content: center; gap: 0.5rem; }
        .card { background-color: var(--card-bg-color); padding: 1.5rem; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); margin-bottom: 2rem; border: 1px solid var(--border-color); }
        
        /* グラデーションアニメーションの定義 */
        @keyframes rainbow-border-animation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* グラデーション枠を適用する特定のカードのためのクラス */
        .rainbow-border-card {
            border: 3px solid transparent; /* 枠線の太さを確保し、透明にする */
            background-origin: border-box;
            background-clip: padding-box, border-box; /* 内側と外側で背景の描画範囲を分ける */
            
            /* 背景を2つ指定: 1つ目はカードの内側の背景色、2つ目は枠線のグラデーション */
            background-image: linear-gradient(var(--card-bg-color), var(--card-bg-color)), 
                              linear-gradient(135deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            
            background-size: 100% 100%, 400% 400%; /* アニメーションのためにグラデーションのサイズを大きく設定 */
            animation: rainbow-border-animation 8s linear infinite;
        }

        .input-group { display: flex; flex-direction: column; gap: 1rem; }
        label { font-weight: 500; }
        textarea, input[type="text"], input[type="number"], input[type="password"] { width: 100%; padding: 0.8rem; border-radius: 4px; border: 1px solid var(--border-color); background-color: var(--input-bg-color); color: var(--text-color); font-size: 1rem; font-family: 'Roboto', monospace; }
        textarea { min-height: 120px; resize: vertical; }
        button { padding: 0.8rem 1.5rem; background-color: var(--primary-color); color: var(--primary-text-color); border: none; border-radius: 4px; font-size: 1.1rem; font-weight: 700; cursor: pointer; transition: background-color 0.2s; }
        button:hover { opacity: 0.9; }
        .icon-button { background: none; border: 1px solid var(--border-color); padding: 0.5rem; border-radius: 50%; width: 40px; height: 40px; display: flex; justify-content: center; align-items: center; color: var(--text-color); }
        .icon-button svg { width: 20px; height: 20px; }
        #results { display: none; }
        .stats-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-top: 1rem; }
        .stat-item { padding: 1rem; border: 1px solid var(--border-color); border-radius: 6px; display: flex; flex-direction: column; }
        .stat-item h3 { margin-bottom: 0.5rem; }
        .stat-value { font-size: 1.8rem; font-weight: 700; color: var(--primary-text-color); background-color: var(--primary-color); padding: 0.2rem 0.5rem; border-radius: 4px; display: inline-block; margin-bottom: 1rem; word-break: break-all; }
        .formula { font-size: 1.1rem; padding: 0.5rem; background-color: var(--input-bg-color); border-radius: 4px; overflow-x: auto; flex-grow: 1; }
        .table-container { overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
        th, td { border: 1px solid var(--border-color); padding: 0.8rem; text-align: center; }
        thead { background-color: var(--table-header-bg); font-weight: 700; }
        tfoot { background-color: var(--table-header-bg); font-weight: 700; }
        #dataTable td { padding: 0.5rem; }
        .chart-container { width: 100%; height: 400px; }
        .explanation { padding: 0.5rem; margin-bottom: 0.5rem; border-left: 3px solid var(--primary-color); background-color: var(--highlight-bg); }
        .formula p { word-break: break-all; }
        .disclaimer { font-size: 0.8rem; text-align: center; opacity: 0.7; margin-top: 1rem; }
        .loader-container { display: none; flex-direction: column; justify-content: center; align-items: center; min-height: 100px; }
        .loader { width: 60px; height: 60px; animation: rotate 1s linear infinite; transform-origin: center center; }
        .loader .path { stroke: var(--spinner-color); stroke-linecap: round; stroke-dasharray: 89 150; stroke-dashoffset: 0; }
        @keyframes rotate { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <main>
        <header>
            <h1>AI搭載 統計データ自動分析ツール</h1>
        </header>

        <div class="card">
            <h2>データ入力</h2>
            <div class="input-group">
                <label for="dataInput">データをカンマ(,)、スペース、または改行で区切って入力してください。</label>
                <textarea id="dataInput" placeholder="例: 1, 2, 2, 3, 5, 8, 10, 11, 15, 16, 18, 22"></textarea>
                <label for="binWidth">ヒストグラムの階級の幅（整数・小数）</label>
                <!-- --- ここから修正 --- -->
                <input type="number" id="binWidth" value="5" min="0.1" step="any">
                <!-- --- ここまで修正 --- -->
                <button id="calculateBtn">分析する</button>
            </div>
        </div>
        <div id="results">
            <div class="card rainbow-border-card">
                <h2 class="flex-header">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-stars" viewBox="0 0 16 16"><path d="M7.657 6.247c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937-.645a2.89 2.89 0 0 0 1.828-1.828zM3.794 1.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387A1.73 1.73 0 0 0 4.593 5.69l-.387 1.162a.217.217 0 0 1-.412 0L3.407 5.69A1.73 1.73 0 0 0 2.31 4.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387A1.73 1.73 0 0 0 3.407 2.31zM10.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.16 1.16 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.16 1.16 0 0 0-.732-.732L9.1 2.137a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732z"/></svg>
                    AIによるデータ要約
                </h2>
                <div id="aiSpinner" class="loader-container">
                    <svg class="loader" viewBox="0 0 50 50">
                        <circle class="path" cx="25" cy="25" r="20" fill="none" stroke-width="4"></circle>
                    </svg>
                </div>
                <div id="aiSummaryContent"></div>
                <p class="disclaimer">AIによるデータ要約には、間違いが含まれている場合があります。</p>
            </div>
            <div class="card">
                <h2>基本統計量</h2>
                <div class="stats-container">
                    <div class="stat-item"><h3>合計値 (Sum)</h3><div id="sumValue" class="stat-value"></div><div class="formula" id="sumFormula"></div></div>
                    <div class="stat-item"><h3>平均値 (Mean)</h3><div id="meanValue" class="stat-value"></div><div class="formula" id="meanFormula"></div></div>
                    <div class="stat-item"><h3>中央値 (Median)</h3><div id="medianValue" class="stat-value"></div><div class="formula" id="medianFormula"></div></div>
                    <div class="stat-item"><h3>最頻値 (Mode)</h3><div id="modeValue" class="stat-value"></div><div class="formula" id="modeFormula"></div></div>
                </div>
            </div>
            <div class="card"><h2>データ一覧（入力順）</h2><div class="table-container"><table id="dataTable"><tbody></tbody></table></div></div>
            <div class="card"><h2>度数分布表</h2><div class="table-container"><table id="frequencyTable"><thead><tr><th>階級</th><th>度数（個数）</th></tr></thead><tbody></tbody><tfoot></tfoot></table></div></div>
            <div class="card"><h2>ドットプロット</h2><div id="dotPlotContainer" class="chart-container"></div></div>
            <div class="card"><h2>ヒストグラム（柱状グラフ）</h2><div id="histogramContainer" class="chart-container"></div></div>
            <div class="card"><h2>折れ線グラフ</h2><div id="lineChartContainer" class="chart-container"></div></div>
            <div class="card"><h2>棒グラフ</h2><div id="barChartContainer" class="chart-container"></div></div>
            <div class="card"><h2>円グラフ</h2><div id="pieChartContainer" class="chart-container"></div></div>
            <div class="card"><h2>帯グラフ</h2><div id="obiChartContainer" class="chart-container"></div></div>
            <div class="card"><h2>レーダーチャート</h2><div id="radarChartContainer" class="chart-container"></div></div>
        </div>
    </main>

    <script>
        // --- ★★★ 重要 ★★★ ---
        // Cloudflare WorkerのURLを設定します。
        // ご自身のWorkerのURLに書き換えてください。
        const WORKER_URL = 'https://math-solver-proxy.nden14800.workers.dev';

        document.addEventListener('DOMContentLoaded', () => {
            const calculateBtn = document.getElementById('calculateBtn');
            calculateBtn.addEventListener('click', analyzeData);
            
            // KaTeXのauto-renderをDOMContentLoaded後にも実行できるように準備
            // KaTeXのCDNスクリプト自体がdeferで読み込まれるため、
            // window.renderMathInElementが存在するか確認してから呼び出す
            if (window.renderMathInElement) {
                renderMathInElement(document.body);
            }
        });
        
        async function analyzeData() {
            const rawData = document.getElementById('dataInput').value;
            const numbersAsInput = rawData.split(/[\s,]+/).filter(n => n !== "").map(Number).filter(n => !isNaN(n));
            if (numbersAsInput.length === 0) { alert('有効なデータが入力されていません。'); return; }

            const originalNumbers = [...numbersAsInput];
            const sortedNumbers = [...numbersAsInput].sort((a, b) => a - b);
            
            const sum = calculateSum(sortedNumbers);
            const mean = calculateMean(sortedNumbers);
            const median = calculateMedian(sortedNumbers);
            const modeResult = calculateMode(sortedNumbers);
            // --- ここから修正 ---
            const binWidth = parseFloat(document.getElementById('binWidth').value);
            if (isNaN(binWidth) || binWidth <= 0) { alert('階級の幅は正の数で入力してください。'); return; }
            // --- ここまで修正 ---

            const frequencyData = createFrequencyData(sortedNumbers, binWidth);
            const dotPlotData = createDotPlotData(sortedNumbers);
            
            displayResults(sum, mean, median, modeResult.text, sortedNumbers);
            renderDataTable(originalNumbers);
            renderFrequencyTable(frequencyData);
            
            setHighchartsTheme();
            renderDotPlot(dotPlotData);
            renderHistogram(frequencyData);
            // --- ここから修正 ---
            renderLineChart(originalNumbers); // ソート前のデータを渡す
            renderBarChart(originalNumbers);  // ソート前のデータを渡す
            // --- ここまで修正 ---
            renderPieChart(frequencyData);
            renderObiChart(frequencyData);
            renderRadarChart(frequencyData);

            await getAISummary(sortedNumbers, { sum, mean, median, mode: modeResult.text });

            if (window.renderMathInElement) {
                renderMathInElement(document.body, {
                    delimiters: [ {left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false} ]
                });
            }
        }
        
        // API呼び出しをWorker経由で行う共通関数
        async function callApiViaWorker(prompt) {
            if (!WORKER_URL || WORKER_URL.includes('<あなたのWorker名>')) {
                throw new Error('Cloudflare WorkerのURLが設定されていません。コードを編集してください。');
            }
            try {
                const response = await fetch(WORKER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: prompt })
                });
                const data = await response.json();
                if (!response.ok) {
                    throw new Error(data.error || `サーバーからのエラー: ${response.status}`);
                }
                const text = data?.candidates?.[0]?.content?.parts?.[0]?.text;
                if (text) {
                    return text;
                } else {
                    const finishReason = data?.candidates?.[0]?.finishReason;
                    let errorMessage = 'AIが回答を生成できませんでした。';
                    if (finishReason === 'SAFETY') {
                        errorMessage += ' 安全性の設定によりブロックされた可能性があります。';
                    } else if (finishReason) {
                        errorMessage += ` (理由: ${finishReason})`;
                    }
                    throw new Error(errorMessage);
                }
            } catch (error) {
                console.error('API呼び出しエラー:', error);
                if (error instanceof TypeError) {
                    throw new Error('ネットワークエラー、またはCORS設定の問題の可能性があります。');
                }
                throw error;
            }
        }

        // getAISummary関数
        async function getAISummary(data, stats) {
            const aiSpinner = document.getElementById('aiSpinner');
            const aiSummaryContent = document.getElementById('aiSummaryContent');
            aiSummaryContent.innerHTML = '';
            aiSpinner.style.display = 'flex';
            
            const prompt = `あなたは優秀なデータ分析アシスタントです。以下のデータセットとその基本統計量に基づいて、データの特性について簡潔で分かりやすい要約を作成してください。重点的に分析するポイント：- 中心の傾向：平均値と中央値は近いか？どちらがデータ全体をよりよく表しているか？- ばらつき：データの範囲（最小値と最大値）は広いか？特定の値に集中しているか？- 分布の形状：最頻値は存在するか？データは山のような形をしているか、それとも平坦か？---### データセット (${data.length}個)\n${data.join(', ')}\n\n### 基本統計量\n- 合計値: ${stats.sum.toLocaleString()}\n- 平均値: ${stats.mean.toFixed(3)}\n- 中央値: ${stats.median.toFixed(3)}\n- 最頻値: ${stats.mode}\n---以上の情報を基に、データ全体の傾向を要約してください。`;
            
            try {
                const summaryText = await callApiViaWorker(prompt);
                aiSummaryContent.textContent = summaryText;
            } catch (error) {
                console.error('AI要約の生成に失敗しました:', error);
                aiSummaryContent.innerHTML = `<p style="color: red;">要約の生成中にエラーが発生しました: ${error.message} ブラウザのコンソールで詳細を確認してください。</p>`;
            } finally {
                aiSpinner.style.display = 'none';
            }
        }
        
        function calculateSum(arr) { return arr.reduce((acc, val) => acc + val, 0); }
        function calculateMean(arr) { return arr.length > 0 ? arr.reduce((acc, val) => acc + val, 0) / arr.length : 0; }
        function calculateMedian(arr) { const mid = Math.floor(arr.length / 2); return arr.length % 2 !== 0 ? arr[mid] : (arr[mid - 1] + arr[mid]) / 2; }
        function calculateMode(arr) {
            const freq = arr.reduce((acc, val) => { acc[val] = (acc[val] || 0) + 1; return acc; }, {});
            let maxFreq = 0, modes = [];
            for (const num in freq) { if (freq[num] > maxFreq) { modes = [Number(num)]; maxFreq = freq[num]; } else if (freq[num] === maxFreq) { modes.push(Number(num)); } }
            if (modes.length === Object.keys(freq).length && modes.length > 1) return { text: "なし", values: [] };
            return { text: modes.join(', '), values: modes };
        }
        
        function createFrequencyData(numbers, binWidth) {
            if (numbers.length === 0) return [];
            const min = numbers[0];
            const max = numbers[numbers.length - 1];
            const bins = {};
            // 小数点以下の桁数を考慮してラベルをフォーマットするヘルパー関数
            const formatNumber = (num) => {
                // binWidthの小数桁数を取得
                const decimalPlaces = (binWidth.toString().split('.')[1] || '').length;
                return parseFloat(num.toFixed(decimalPlaces));
            };
            for (let i = Math.floor(min / binWidth) * binWidth; i <= max; i += binWidth) { 
                const start = formatNumber(i);
                const end = formatNumber(i + binWidth);
                bins[`${start} 以上 ${end} 未満`] = 0;
            }
            numbers.forEach(num => { 
                const binStart = Math.floor(num / binWidth) * binWidth;
                const start = formatNumber(binStart);
                const end = formatNumber(binStart + binWidth);
                const label = `${start} 以上 ${end} 未満`; 
                if (bins[label] !== undefined) bins[label]++; 
            });
            return Object.entries(bins).map(([label, count]) => ({ label, count }));
        }
        function createDotPlotData(numbers) {
            const freq = {}; numbers.forEach(num => { freq[num] = (freq[num] || 0) + 1; });
            const plotData = [];
            for (const num in freq) { for (let i = 1; i <= freq[num]; i++) { plotData.push({ x: Number(num), y: i }); } }
            return plotData;
        }

        function displayResults(sum, mean, median, modeText, arr) {
            document.getElementById('results').style.display = 'block';
            document.getElementById('sumValue').textContent = sum.toLocaleString();
            document.getElementById('meanValue').textContent = mean.toFixed(3);
            document.getElementById('medianValue').textContent = median.toFixed(3);
            document.getElementById('modeValue').textContent = modeText;
            document.getElementById('sumFormula').innerHTML = `<div class="explanation">合計値は、すべてのデータを足し合わせて求めます。</div>$$ \\text{合計} = ${arr.join(' + ')} $$$$ \\text{合計} = ${sum.toLocaleString()} $$`;
            document.getElementById('meanFormula').innerHTML = `<div class="explanation">平均値(m)は、データの合計をデータの数で割って求めます。</div>$$ m = \\frac{\\text{データの合計}}{\\text{データの数}} $$$$ m = \\frac{${sum.toLocaleString()}}{${arr.length}} \\approx ${mean.toFixed(3)} $$`;
            let medianFormulaHTML = `<div class="explanation">中央値を求めるには、まずデータを小さい順に並べ替えます。</div>`;
            const n = arr.length;
            medianFormulaHTML += `<p>並べ替えたデータ (${n}個):<br>${formatArrayWithHighlight(arr)}</p>`;
            if (n % 2 !== 0) {
                const midIndex = Math.floor(n / 2);
                medianFormulaHTML += `<div class="explanation">データ数が奇数 (${n}個) の場合は、真ん中 (${midIndex + 1}番目) の値が中央値です。</div><p>${formatArrayWithHighlight(arr, [midIndex])}</p>$$ \\text{中央値} = ${arr[midIndex]} $$`;
            } else {
                const mid1 = n / 2 - 1, mid2 = n / 2;
                medianFormulaHTML += `<div class="explanation">データ数が偶数 (${n}個) の場合は、真ん中に最も近い2つの値 (${mid1 + 1}番目と${mid2 + 1}番目) の平均値が中央値です。</div><p>${formatArrayWithHighlight(arr, [mid1, mid2])}</p>$$ \\text{中央値} = \\frac{${arr[mid1]} + ${arr[mid2]}}{2} = \\frac{${arr[mid1] + arr[mid2]}}{2} = ${median} $$`;
            }
            document.getElementById('medianFormula').innerHTML = medianFormulaHTML;
            document.getElementById('modeFormula').innerHTML = `<div class="explanation">最頻値は、データの中で最も多く出現する値です。すべてのデータを比較し、最も頻繁に現れる数値を直接見つけます。</div>`;
        }
        
        function renderDataTable(arr) {
            const tbody = document.querySelector('#dataTable tbody');
            tbody.innerHTML = '';
            const cols = 10;
            let tr = document.createElement('tr');
            for (let i = 0; i < arr.length; i++) {
                if (i > 0 && i % cols === 0) { tbody.appendChild(tr); tr = document.createElement('tr'); }
                const td = document.createElement('td'); td.textContent = arr[i]; tr.appendChild(td);
            }
            tbody.appendChild(tr);
        }
        function renderFrequencyTable(data) {
            const table = document.getElementById('frequencyTable');
            const tbody = table.querySelector('tbody');
            const tfoot = table.querySelector('tfoot');
            tbody.innerHTML = '';
            tfoot.innerHTML = '';

            let totalFrequency = 0;
            data.filter(item => item.count > 0).forEach(item => {
                const row = document.createElement('tr');
                row.innerHTML = `<td>${item.label}</td><td>${item.count}</td>`;
                tbody.appendChild(row);
                totalFrequency += item.count;
            });

            const totalRow = document.createElement('tr');
            totalRow.innerHTML = `<td><strong>合計</strong></td><td><strong>${totalFrequency}</strong></td>`;
            tfoot.appendChild(totalRow);
        }
        function setHighchartsTheme() { const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches; const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim(); const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--card-bg-color').trim(); const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim(); Highcharts.setOptions({ chart: { backgroundColor: bgColor, style: { fontFamily: 'Roboto, sans-serif' } }, title: { style: { color: textColor } }, subtitle: { style: { color: textColor } }, xAxis: { labels: { style: { color: textColor } }, title: { style: { color: textColor } }, gridLineColor: gridColor, lineColor: gridColor }, yAxis: { labels: { style: { color: textColor } }, title: { style: { color: textColor } }, gridLineColor: gridColor }, legend: { itemStyle: { color: textColor } }, tooltip: { backgroundColor: isDarkMode ? 'rgba(30, 42, 74, 0.85)' : 'rgba(255, 255, 255, 0.85)', style: { color: textColor } }, credits: { enabled: false } }); }
        function renderDotPlot(data) { const dotColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim(); Highcharts.chart('dotPlotContainer', { chart: { type: 'scatter', zoomType: 'xy' }, title: { text: null }, legend: { enabled: false }, xAxis: { title: { text: '値' } }, yAxis: { title: { text: '度数（積み上げ）' }, min: 0, allowDecimals: false, tickInterval: 1 }, series: [{ name: 'データ点', data: data, color: dotColor, marker: { radius: 5 } }], tooltip: { formatter: function () { return `値: <b>${this.x}</b><br/>${this.y}番目の点`; } } }); }
        function renderHistogram(data) { const barColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim(); const filteredData = data.filter(d => d.count > 0); Highcharts.chart('histogramContainer', { chart: { type: 'column', zoomType: 'x' }, title: { text: null }, legend: { enabled: false }, xAxis: { categories: filteredData.map(d => d.label), title: { text: '階級' } }, yAxis: { min: 0, title: { text: '度数' }, allowDecimals: false }, plotOptions: { column: { pointPadding: 0, borderWidth: 1, groupPadding: 0, shadow: false, borderColor: getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim() } }, series: [{ name: '度数', data: filteredData.map(d => d.count), color: barColor }], tooltip: { headerFormat: '<span style="font-size:10px">{point.key}</span><table>', pointFormat: '<tr><td style="padding:0">度数: </td><td style="padding:0"><b>{point.y}</b></td></tr>', footerFormat: '</table>', useHTML: true } }); }
        
        // --- ここから修正 ---
        function renderLineChart(arr) {
            const lineColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
            Highcharts.chart('lineChartContainer', {
                chart: { type: 'line', zoomType: 'x' },
                title: { text: '入力データの推移' },
                legend: { enabled: false },
                xAxis: { title: { text: '入力順' } },
                yAxis: { title: { text: '値' } },
                series: [{ name: '値', data: arr, color: lineColor }]
            });
        }
        function renderBarChart(arr) {
            const barColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
            Highcharts.chart('barChartContainer', {
                chart: { type: 'column', zoomType: 'x' },
                title: { text: '入力データの値' },
                legend: { enabled: false },
                xAxis: {
                    categories: arr.map((_, index) => `${index + 1}番目`),
                    title: { text: '入力順' },
                    crosshair: true
                },
                yAxis: {
                    min: 0,
                    title: { text: '値' }
                },
                series: [{
                    name: '値',
                    data: arr,
                    color: barColor
                }],
                tooltip: {
                    headerFormat: '<span style="font-size:10px">{point.key}</span><table>',
                    pointFormat: '<tr><td style="padding:0">値: </td><td style="padding:0"><b>{point.y}</b></td></tr>',
                    footerFormat: '</table>',
                    useHTML: true
                }
            });
        }
        // --- ここまで修正 ---

        function renderPieChart(data) { const filteredData = data.filter(d => d.count > 0); Highcharts.chart('pieChartContainer', { chart: { type: 'pie' }, title: { text: '度数の割合' }, tooltip: { pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>' }, plotOptions: { pie: { allowPointSelect: true, cursor: 'pointer', dataLabels: { enabled: true, format: '<b>{point.name}</b>: {point.percentage:.1f} %' } } }, series: [{ name: '割合', data: filteredData.map(d => ({ name: d.label, y: d.count })) }] }); }
        function renderObiChart(data) { const filteredData = data.filter(d => d.count > 0); Highcharts.chart('obiChartContainer', { chart: { type: 'bar' }, title: { text: '度数の構成比（帯グラフ）' }, xAxis: { categories: ['構成比'] }, yAxis: { min: 0, title: { text: 'パーセンテージ' } }, legend: { reversed: true }, plotOptions: { series: { stacking: 'percent' } }, series: filteredData.map(d => ({ name: d.label, data: [d.count] })) }); }
        function renderRadarChart(data) { const filteredData = data.filter(d => d.count > 0); Highcharts.chart('radarChartContainer', { chart: { polar: true, type: 'line' }, title: { text: '度数レーダーチャート' }, pane: { size: '80%' }, xAxis: { categories: filteredData.map(d => d.label), tickmarkPlacement: 'on', lineWidth: 0 }, yAxis: { gridLineInterpolation: 'polygon', lineWidth: 0, min: 0 }, series: [{ name: '度数', data: filteredData.map(d => d.count), pointPlacement: 'on' }] }); }
        function formatArrayWithHighlight(arr, highlightIndices = []) { const content = arr.map((val, i) => highlightIndices.includes(i) ? `<strong>${val}</strong>` : val).join(', '); return `[${content}]`; }
    </script>
</body>
</html>
